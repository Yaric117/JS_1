'use strict'

//задание урок 2
//1.

//var a = 1, b = 1, c, d;
//c = ++a; alert(c); 2
/*потому что, инкремент имеет
префиксную форму и поэтому сразу возвращает 
значение на единицу больше */

//d = b++; alert(d); 1
/* по сути тоже самое, что и в первом
случае только здесь операнд имеет постфиксное 
значение инкремента и поэтому сначала возвращает значение, 
а потом, к примеру если еще раз вызвать alert(), 
вернет значение на единицу больше */

//c = (2 + ++a); alert(c); 5 
/*пока мы комментрировали 
предыдущие операции, операнд "а" успел увеличится 
до значения 2, и в данной операции мы его еще 
раз инкрементировали в префиксной форме. 
Поэтому он уже стал равен 3, ну и т.к. мы 
знаем из школы, что 2 + 3 = 5, то все сходится :)*/

//d = (2 + b++); alert(d); 4  
/*все тоже самое, что я писал
выше, только здесь мы видим операнд "b" и он 
увеличился к нашей операции до значения 2, и 
в нашем случае мы его инкрементируем постфиксной 
формой, поэтому на 1 он не успеет увеличиться, 
поэтому, опять же, возвращаясь в школу 
2 + 2 =4*/

//alert(a); 3 
/*собственно все описано выше, 
значение переменной "а" инкрементированно 
с 1 до 3*/

//alert(b); 3 
/*тоже, что и с "a", почему в
переменной "d", значение "b" было равным 2? 
опять же в результате работы постпрефиксной 
формы инкремента, если бы мы повторно выполнили 
данную операцию, то работали бы уже с операндом 
"b", имеющим значение 3*/

//2. Чему будет равен x в примере ниже?

//var a = 2;
//var x = 1 + (a *= 2);
/* если развернуто, как Вы любите, то поехали:
что произошло, мы объявили перемнную "а",
далее мы объявили переменную "x",
в которой содержутся две оперции с использованием
бинарных операторов, а именно сложение и умножение....
в нашем случае сначала выполнится операция умножения,
потому, как она заключена в скобки, а это приоритет, как
мы знаем, оперция умножения у нас записана в короткой форме,
что означает развернуто a = a * 2....в нашем случае a = 2
снова в школу 2 * 2 = 4....далее к полученному значению
мы прибавляем 1 и получаем x = 5 */

/* 3. Объявить две целочисленные переменные a и b и задать 
им произвольные начальные значения. Затем написать скрипт, 
который работает по следующему принципу: */

confirm('Задайте два числа в диапазоне от -100 до +100. Если числа положительные - выводит их разность, если отрицательные выводит их произведение, если разных знаков выводит сумму');
function lesson_two() {
    let a = Number(prompt("Введите значение переменной a в диапазоне от -100 до +100:"));
    let b = Number(prompt("Введите значение переменной b в диапазоне от -100 до +100:"));
    let c;

    if (a >= 0 && b >= 0) {
        c = a - b
        alert('Значение a и b являются положительными, результат: ' + c);

    }
    else {
        if (a < 0 && b < 0) {
            c = a * b
            alert('Значение a и b являются отрицательными, результат: ' + c);
        }
        else {
            if (a >= 0 && b < 0 || a < 0 && b >= 0) {
                c = a + b
                alert('Значение a и b разных знаков, результат: ' + c);
            }
        }
    }

    let d = confirm('Желаете продолжить?');
    if (d == true) {
        lesson_two();
    } else {
        alert('До новых встреч!');
        return;
    }
}
lesson_two();

//4* все тоже самое, только без switch
let e = Number(prompt("Введите значение переменной e в диапазоне от 0 до 15:"));
let f;
let n = 0;
function account() {
    alert(f = e++);
    n = n++;
    if (n === 16 - e) {
        return;
    }
    account()
}
account();

//5*
function operation(h, j) {
    let sum = Number();
    sum = h + j;
    alert('Результат суммы: ' + sum);
    sum -= sum;
    sum = h - j;
    alert('Результат разности: ' + sum);
    sum -= sum;
    sum = h * j;
    alert('Результат умножения: ' + sum);
    sum -= sum;
    sum = h / j;
    alert('Результат деления: ' + sum);
}
operation(2, 2);


//6*
let _operation = prompt("Enter operation: addition, subtraction, multiplication or degree");
function mathOperation(arg1, arg2, _operation) {

    switch (_operation) {
        case 'addition':
            return arg1 + arg2;
        case 'subtraction':
            return arg1 - arg2;
        case 'multiplication':
            return arg1 * arg2;
        case 'degree':
            return arg1 / arg2;


    }
}
let finish_result = mathOperation(2, 2, _operation);
alert(finish_result);

//7*
/* console.log(null == 0);
console.log(null > 0);
console.log(null < 0);
console.log(null <= 0);
console.log(null >= 0); */
/* по поводу > и < тут понятно, 0 не может быть больше либо
меньше самого себя, так как null преобразуется в +0. 
Вот по "==" уже интересней, если смотреть 
абстрактный алгоритм сравнения для равенств, 
который возвращает в результате true или false (можно посмотреть
в сети если интересно)то, если коротко, алгоритм 
проверяет две переменные a и b на соответсвие типу, приводя
различные варианты, и в зависимости от результата возвращает
true или false, и состоит он из 22 строк . Наш случай, это 
строка 14, где говорится, что у нас переменные a и b относятся 
к разным типам...и так  получилось, что после строки 14 ни 
одна из последующих строк, за исключением последней нам не 
подходят, а последня стока просто возвращает значение false, 
вот такие причуды JS.
A по поводу >= и <= если у нас есть два числа a и b, a<b false и 
a>=b true, т.е. если  a не меньше b, то как миниму оно больше,
либо равно (математика). То же самое в обратном случае*/

//8*



function power(val, pow) {
    if (pow != 1) {
        return val = val * power(val, pow - 1);
    } else {
        return val;
    }

}
alert(power(2, 2));














